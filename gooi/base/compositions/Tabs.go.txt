package compositions
import (
	intf 	"gooi/interfaces"
	cons 	"gooi/base/constants"
	comp 	"gooi/base/components"
	event 	"gooi/base/event"
	ly 		"gooi/base/compositions/layout"
	colours "gooi/base/colours"
	fmt 	"fmt"
)
type Tabs struct {
	name string
	layout *ly.Layout

	labels 				[]string

	mouseHandler 		intf.MouseHandler_Interface
	eventHandler 		intf.EventHandler_Interface

	slaveWidth, slaveHeight float32
	slaveWidthRatio, slaveHeightRatio float32

	posX, posY, posZ float32

	// master box that stores all components of tabs 
	// and column structure to store button row and stacked tabs
	masterTabBox 		*Box
	tabColumn 			*Column	
	// button row to store buttons for each tab
	tabButtonBox 		*Box
	tabButtonRow 		*Row
	tabButton 			[]*comp.Button
	// actual boxes (super imposed)
	// needs a rectangular background element to do correct z-position overlaying. 
	tabStack  	 		*Stack
	tabs  	 			[]*Box
}

func NewTabComposition(
	name string, 
	canvas intf.Canvas_Interface, 
	masterStruct intf.Displayable,
	eventhandler intf.EventHandler_Interface, 
	mousehandler intf.MouseHandler_Interface, 
	labels []string, 
	x, y, z, slaveWidthRatio, slaveHeightRatio float32,
	font_name, font_path string,
	font_size int,
) (*Tabs) {
	var tabs = Tabs{
		name,
		ly.NewLayout(canvas, masterStruct),
		labels,
		mousehandler, eventhandler,

		slaveWidthRatio * masterStruct.GetWidth(), 
		slaveHeightRatio * masterStruct.GetHeight(),
		slaveWidthRatio, slaveHeightRatio,

		x, y, z,
		// master struct of these nested structs are the struct being created now.
		// so we must initialise these later to avoid throwing an error. 
		nil, nil, nil, nil, nil, nil, nil,
	}
	/** Creating container that holds everything **/
	tabs.masterTabBox = NewBoxComposition(
		fmt.Sprintf("%s_masterBox", name),
		canvas, 
		masterStruct,
		0, 0, 0, 1, 1,
		cons.ALIGN_TOP_LEFT,
		colours.WHITE,
	)
	/** Creating the column that holds the buttons and tab boxes **/
	tabs.tabColumn = NewColumnComposition(
		fmt.Sprintf("%s_column", name),
		canvas,
		tabs.masterTabBox,
		0, 0, 0, 1, 1, 
		cons.ALIGN_CENTRE_COLUMN,
	)
	/** Creating the tab button row **/
	tabs.tabButtonBox = NewBoxComposition(
		fmt.Sprintf("%s_tabs_button_box", name),
		canvas,
		tabs.tabColumn,
		0, 0, 0, 1, 1,
		cons.ALIGN_TOP_LEFT,
		colours.RED,
	)
	tabs.tabButtonRow = NewRowComposition(
		fmt.Sprintf("%s_tabs_button_row", name),
		canvas,
		tabs.tabButtonBox,
		0, 0, 0, 1, 1,
		cons.ALIGN_CENTRE_ROW,
	)
	
	/** Creating the buttons **/
	tabs.tabButton = make([]*comp.Button, len(labels))
	for i, label := range labels {
		fmt.Printf("Creating tab button with label %s\n", label)
		var event_arguments = event.NewEventParameter(i)
		// creating event 
		var selectTab_event = &event.Event_Struct{
			tabs.MoveToFront, 
			fmt.Sprintf("selectTab_%v", i),
			event_arguments,
		}
		tabs.tabButton[i] = comp.CreateButton(
			canvas,
			tabs.tabButtonRow,
			fmt.Sprintf("%s_button_%v_%s", name, i, label),
			100, 20,
			5,
			0, 0, 0, 
			font_name, font_path,
			font_size, 
			selectTab_event,
			100,
		)
		canvas.GetWindow().GetMouseHandler().RegisterClickableToHandler(tabs.tabButton[i])
	}

	/** Creating tabs (boxes) based upon given labels **/
	var alignment = []int{}
	for i := 0; i < len(labels) ; i++ {
		alignment =  append(alignment, cons.ALIGN_TOP_LEFT)
	}

	fmt.Printf("Alignment is %v\n", alignment)

	tabs.tabStack = NewStackComposition(
		fmt.Sprintf("%s_tabBox", name),
		canvas, 
		tabs.tabColumn,
		0, 0, 0, 0.5, 0.5, 
		alignment,
	)

	tabs.tabs = make([]*Box, len(labels))
	for i, label := range labels {
		fmt.Printf("Creating tab box for label %s %v\n", label, i)
		tabs.tabs[i] = NewBoxComposition(
			fmt.Sprintf("%s_tab_%s", name, label), 
			canvas, 
			tabs.tabStack,	
			0, 0, 0, 1, 1, 
			cons.ALIGN_TOP_LEFT,
			colours.GRAY,
		)
	}
	
	// initial arragement of layout
	for i, _ := range tabs.tabButton {
		tabs.tabButtonRow.AddDisplayable(tabs.tabButton[i])
	}
	tabs.tabButtonBox.AddDisplayable(tabs.tabButtonRow)

	for i, _ := range tabs.tabs {
		tabs.tabStack.AddDisplayable(tabs.tabs[i])
	}

	tabs.tabColumn.AddDisplayable(tabs.tabButtonBox)
	tabs.tabColumn.AddDisplayable(tabs.tabStack)

	tabs.masterTabBox.AddDisplayable(tabs.tabColumn)

	return &tabs
}

func (tabs *Tabs) MoveToFront(param intf.Paramaters_Interface) {
	var Index = param.GetParameters().(int)
	for i, _ := range tabs.tabs {
		var x, y, _ = tabs.tabs[i].GetPos()
		tabs.tabs[i].SetPos(x, y, 0.0) 
	}
	var x, y, _ = tabs.tabs[Index].GetPos()
	tabs.tabs[Index].SetPos(x, y, 1.0) 
	tabs.Redraw()

}

func (tabs *Tabs) ArrangeLayout() {
	//tabs.masterTabBox.ArrangeLayout()
}

func (tabs *Tabs) Draw(){
	tabs.masterTabBox.Draw()
}

func (tabs *Tabs) Redraw(){
	tabs.ArrangeLayout()
	tabs.masterTabBox.Redraw()
}

func (tabs *Tabs) SetPos(x, y, z float32){
	tabs.posX = x
	tabs.posY = y
	tabs.posZ = z
	tabs.Redraw()
}
func (tabs *Tabs) GetPos() (float32, float32, float32){
	return tabs.posX, tabs.posY, tabs.posZ
}

func (tabs *Tabs) AddDisplayable(displayable intf.Displayable, tab int) {
	tabs.tabs[tab].AddDisplayable(displayable)
}

func (tabs *Tabs) GetWidth() float32 { return tabs.slaveWidth }
func (tabs *Tabs) GetHeight() float32 { return tabs.slaveHeight }

func (tabs *Tabs) SetWidth(w float32) { tabs.slaveWidth = w }
func (tabs *Tabs) SetHeight(h float32) { tabs.slaveHeight = h }

func (tabs *Tabs) GetMasterStruct() intf.Displayable { return tabs.layout.GetMasterStruct() }
func (tabs *Tabs) SetMasterStruct(master intf.Displayable) { tabs.layout.SetMasterStruct(master) }